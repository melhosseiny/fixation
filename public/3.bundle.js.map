{"version":3,"sources":["webpack:///./app/js/algorithm.js","webpack:///./app/js/eye.js","webpack:///./app/js/storage.js","webpack:///./node_modules/pixelmatch/index.js","webpack:///./app/js/replay/template.js","webpack:///./app/js/replay/replay.js","webpack:///./app/js/color.js","webpack:///./app/js/geo.js"],"names":["Algorithm","spec","Object","freeze","relative","a","x","b","limit","normalize","min","max","INIT_FIXATION_WINDOW","REPLAY_FPS","GazePoint","y","t","getX","getY","getTimestamp","Fixation","d","getDuration","getFixation","GazeWindow","points","detector","pointsX","map","p","DEVICE_WIDTH","pointsY","DEVICE_HEIGHT","Math","dispersion","reduce","length","toFixed","centroid","Storage","id","put","document","caches","open","then","cache","Response","get","async","callback","response","match","Request","json","value","undefined","clear","cacheName","delete","deleted","getKeys","keys","usage","navigator","storage","estimate","module","exports","img1","img2","output","width","height","options","isPixelData","Error","defaultOptions","len","a32","Uint32Array","buffer","byteOffset","b32","identical","i","diffMask","drawGrayPixel","alpha","maxDelta","threshold","diff","pos","delta","colorDelta","abs","includeAA","antialiased","drawPixel","diffColorAlt","diffColor","aaColor","arr","ArrayBuffer","isView","constructor","BYTES_PER_ELEMENT","img","x1","y1","x0","y0","x2","y2","minX","minY","maxX","maxY","zeroes","hasManySiblings","pos2","k","m","yOnly","r1","g1","b1","a1","r2","g2","b2","a2","blend","rgb2y","rgb2i","q","rgb2q","r","g","c","val","fullscreen","getElementById","getContext","canvas","webkitRequestFullScreen","Replay","prevFixation","tiles","Rect","heatmap","Heatmap","frames","heatmapVisible","showHeatmap","firstTimestamp","requestId","fps","now","Date","interval","play","console","log","playing","cancelAnimationFrame","requestAnimationFrame","replay","render","seekStyle","position","seek","prevPosition","reset","load","Array","fill","forEach","shift","data","renderTmpl","html","time","totalTime","template","Duration","fromMillis","toFormat","context","frame","fixation","count","getCountArr","gaze_buffer","gaze","Float32Array","worker","postMessage","Image","onload","drawImage","Circle","FIXATION_COLOR","Line","SACCADE_COLOR","timestamp","src","start","v","push","connect","Worker","onmessage","e","setCountArr","onerror","disconnect","RAW_DATA_COLOR","CLEAR_COLOR","DIFFERENT_COLORS","HEATMAP_COLORS","h","sqrt","hsl","hue","sat","round","Color","algorithm","heat","rel","window","screen","devicePixelRatio","color","Point","fillStyle","fillRect","Points","renderTimeline","axis","dim","strokeStyle","beginPath","moveTo","lineTo","stroke","getR","arc","PI","GT_BASE","getWidth","getHeight","tileSize","rectangle","containsPoint","px","py","w","strokeRect","Uint16Array","countClone","getCount","setCount","count2","byteLength","global_max","tile","slice","Ease","linear"],"mappings":"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","file":"3.bundle.js","sourcesContent":["export function Algorithm(spec = {}) {\r\n  let relative = function(a, x, b) {\r\n    return (x - a) / (b - a);\r\n  }\r\n\r\n  let limit = function(a, x, b) {\r\n    if(x < a) return a;\r\n    if(x > b) return b;\r\n    return x;\r\n  }\r\n\r\n  let normalize = function(x, min, max) {\r\n    if (x < min) { x = min; }\r\n    if (x > max) { x = max; }\r\n    return (x - min) / (max - min);\r\n  }\r\n\r\n  return Object.freeze({\r\n    relative,\r\n    limit,\r\n    normalize\r\n  });\r\n}\r\n","import {DEVICE_WIDTH, DEVICE_HEIGHT} from './geo.js';\r\n\r\nexport const DISPERSION_THRESHOLD = 50; // pixels\r\nexport const DURATION_THRESHOLD = 150; // ms\r\nexport const INIT_FIXATION_WINDOW = 10; // ~0.15 * 70Hz\r\n\r\nexport const REPLAY_FPS = 5;\r\n\r\nexport function GazePoint(spec = {x: 0, y: 0, t: 0}) {\r\n  let {x,y,t} = spec\r\n\r\n  let getX = function() { return x; }\r\n  let getY = function() { return y; }\r\n  let getTimestamp = function() { return t; }\r\n\r\n  return Object.freeze({\r\n    getX,\r\n    getY,\r\n    getTimestamp\r\n  })\r\n}\r\n\r\nexport function Fixation(spec = {x: 0, y: 0, t: 0, d: 0}) {\r\n  let {x,y,t,d} = spec;\r\n\r\n  let getX = function() { return x; }\r\n  let getY = function() { return y; }\r\n  let getTimestamp = function() { return t; }\r\n  let getDuration = function() { return d; }\r\n\r\n  let getFixation = function() {\r\n    return {x: x, y: y};\r\n  }\r\n\r\n  return Object.freeze({\r\n    getX,\r\n    getY,\r\n    getTimestamp,\r\n    getDuration,\r\n    getFixation\r\n  })\r\n}\r\n\r\nexport function GazeWindow(spec = {points: []}) {\r\n  let {points} = spec;\r\n\r\n  let dispersion = function() {\r\n    let pointsX = points.map(p => p.getX() * DEVICE_WIDTH);\r\n    let pointsY = points.map(p => p.getY() * DEVICE_HEIGHT);\r\n\r\n    return (Math.max(...pointsX) - Math.min(...pointsX)) + (Math.max(...pointsY) - Math.min(...pointsY));\r\n  }\r\n\r\n  let centroid = function() {\r\n    let pointsX = points.map(p => p.getX());\r\n    let pointsY = points.map(p => p.getY());\r\n\r\n    return Fixation({\r\n      x: +(pointsX.reduce((a,b) => a+b) / pointsX.length).toFixed(6),\r\n      y: +(pointsY.reduce((a,b) => a+b) / pointsY.length).toFixed(6),\r\n      t: +(points[0].getTimestamp()).toFixed(6),\r\n      d: +(points[points.length-1].getTimestamp() - points[0].getTimestamp()).toFixed(6)\r\n    })\r\n  }\r\n\r\n  let detector = function() {\r\n    if (dispersion() > DISPERSION_THRESHOLD) {\r\n      return centroid();\r\n    }\r\n    return false;\r\n  }\r\n\r\n  return Object.freeze({\r\n    detector\r\n  })\r\n}\r\n","export function Storage(spec = {}) {\r\n  let id = 0;\r\n\r\n  let put = function(document) {\r\n    caches.open('gaze').then((cache) => {\r\n      const options = {\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        }\r\n      }\r\n      cache.put('/gaze/' + id, new Response(document));\r\n      id = id + 1;\r\n    })\r\n  }\r\n\r\n  let get = async function(id, callback) {\r\n    const cache = await caches.open('gaze');\r\n    const response = await cache.match(new Request('/gaze/' + id));\r\n\r\n    if (response) {\r\n      response.json().then((value) => callback(value));\r\n    } else {\r\n      callback(undefined);\r\n    }\r\n  }\r\n\r\n  let clear = async function(cacheName, callback) {\r\n    caches.delete(cacheName).then((deleted) => callback(deleted));\r\n  }\r\n\r\n  let getKeys = async function(cacheName, callback) {\r\n    const cache = await caches.open(cacheName);\r\n    cache.keys().then((keys) => callback(keys));\r\n  }\r\n\r\n  let usage = function(callback) {\r\n    return navigator.storage.estimate();\r\n  }\r\n\r\n  return Object.freeze({\r\n    put,\r\n    get,\r\n    clear,\r\n    getKeys,\r\n    usage\r\n  })\r\n}\r\n","'use strict';\n\nmodule.exports = pixelmatch;\n\nconst defaultOptions = {\n    threshold: 0.1,         // matching threshold (0 to 1); smaller is more sensitive\n    includeAA: false,       // whether to skip anti-aliasing detection\n    alpha: 0.1,             // opacity of original image in diff ouput\n    aaColor: [255, 255, 0], // color of anti-aliased pixels in diff output\n    diffColor: [255, 0, 0], // color of different pixels in diff output\n    diffColorAlt: null,     // whether to detect dark on light differences between img1 and img2 and set an alternative color to differentiate between the two\n    diffMask: false         // draw the diff over a transparent background (a mask)\n};\n\nfunction pixelmatch(img1, img2, output, width, height, options) {\n\n    if (!isPixelData(img1) || !isPixelData(img2) || (output && !isPixelData(output)))\n        throw new Error('Image data: Uint8Array, Uint8ClampedArray or Buffer expected.');\n\n    if (img1.length !== img2.length || (output && output.length !== img1.length))\n        throw new Error('Image sizes do not match.');\n\n    if (img1.length !== width * height * 4) throw new Error('Image data size does not match width/height.');\n\n    options = Object.assign({}, defaultOptions, options);\n\n    // check if images are identical\n    const len = width * height;\n    const a32 = new Uint32Array(img1.buffer, img1.byteOffset, len);\n    const b32 = new Uint32Array(img2.buffer, img2.byteOffset, len);\n    let identical = true;\n\n    for (let i = 0; i < len; i++) {\n        if (a32[i] !== b32[i]) { identical = false; break; }\n    }\n    if (identical) { // fast path if identical\n        if (output && !options.diffMask) {\n            for (let i = 0; i < len; i++) drawGrayPixel(img1, 4 * i, options.alpha, output);\n        }\n        return 0;\n    }\n\n    // maximum acceptable square distance between two colors;\n    // 35215 is the maximum possible value for the YIQ difference metric\n    const maxDelta = 35215 * options.threshold * options.threshold;\n    let diff = 0;\n\n    // compare each pixel of one image against the other one\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n\n            const pos = (y * width + x) * 4;\n\n            // squared YUV distance between colors at this pixel position, negative if the img2 pixel is darker\n            const delta = colorDelta(img1, img2, pos, pos);\n\n            // the color difference is above the threshold\n            if (Math.abs(delta) > maxDelta) {\n                // check it's a real rendering difference or just anti-aliasing\n                if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) ||\n                                           antialiased(img2, x, y, width, height, img1))) {\n                    // one of the pixels is anti-aliasing; draw as yellow and do not count as difference\n                    // note that we do not include such pixels in a mask\n                    if (output && !options.diffMask) drawPixel(output, pos, ...options.aaColor);\n\n                } else {\n                    // found substantial difference not caused by anti-aliasing; draw it as such\n                    if (output) {\n                        drawPixel(output, pos, ...(delta < 0 && options.diffColorAlt || options.diffColor));\n                    }\n                    diff++;\n                }\n\n            } else if (output) {\n                // pixels are similar; draw background as grayscale image blended with white\n                if (!options.diffMask) drawGrayPixel(img1, pos, options.alpha, output);\n            }\n        }\n    }\n\n    // return the number of different pixels\n    return diff;\n}\n\nfunction isPixelData(arr) {\n    // work around instanceof Uint8Array not working properly in some Jest environments\n    return ArrayBuffer.isView(arr) && arr.constructor.BYTES_PER_ELEMENT === 1;\n}\n\n// check if a pixel is likely a part of anti-aliasing;\n// based on \"Anti-aliased Pixel and Intensity Slope Detector\" paper by V. Vysniauskas, 2009\n\nfunction antialiased(img, x1, y1, width, height, img2) {\n    const x0 = Math.max(x1 - 1, 0);\n    const y0 = Math.max(y1 - 1, 0);\n    const x2 = Math.min(x1 + 1, width - 1);\n    const y2 = Math.min(y1 + 1, height - 1);\n    const pos = (y1 * width + x1) * 4;\n    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;\n    let min = 0;\n    let max = 0;\n    let minX, minY, maxX, maxY;\n\n    // go through 8 adjacent pixels\n    for (let x = x0; x <= x2; x++) {\n        for (let y = y0; y <= y2; y++) {\n            if (x === x1 && y === y1) continue;\n\n            // brightness delta between the center pixel and adjacent one\n            const delta = colorDelta(img, img, pos, (y * width + x) * 4, true);\n\n            // count the number of equal, darker and brighter adjacent pixels\n            if (delta === 0) {\n                zeroes++;\n                // if found more than 2 equal siblings, it's definitely not anti-aliasing\n                if (zeroes > 2) return false;\n\n            // remember the darkest pixel\n            } else if (delta < min) {\n                min = delta;\n                minX = x;\n                minY = y;\n\n            // remember the brightest pixel\n            } else if (delta > max) {\n                max = delta;\n                maxX = x;\n                maxY = y;\n            }\n        }\n    }\n\n    // if there are no both darker and brighter pixels among siblings, it's not anti-aliasing\n    if (min === 0 || max === 0) return false;\n\n    // if either the darkest or the brightest pixel has 3+ equal siblings in both images\n    // (definitely not anti-aliased), this pixel is anti-aliased\n    return (hasManySiblings(img, minX, minY, width, height) && hasManySiblings(img2, minX, minY, width, height)) ||\n           (hasManySiblings(img, maxX, maxY, width, height) && hasManySiblings(img2, maxX, maxY, width, height));\n}\n\n// check if a pixel has 3+ adjacent pixels of the same color.\nfunction hasManySiblings(img, x1, y1, width, height) {\n    const x0 = Math.max(x1 - 1, 0);\n    const y0 = Math.max(y1 - 1, 0);\n    const x2 = Math.min(x1 + 1, width - 1);\n    const y2 = Math.min(y1 + 1, height - 1);\n    const pos = (y1 * width + x1) * 4;\n    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;\n\n    // go through 8 adjacent pixels\n    for (let x = x0; x <= x2; x++) {\n        for (let y = y0; y <= y2; y++) {\n            if (x === x1 && y === y1) continue;\n\n            const pos2 = (y * width + x) * 4;\n            if (img[pos] === img[pos2] &&\n                img[pos + 1] === img[pos2 + 1] &&\n                img[pos + 2] === img[pos2 + 2] &&\n                img[pos + 3] === img[pos2 + 3]) zeroes++;\n\n            if (zeroes > 2) return true;\n        }\n    }\n\n    return false;\n}\n\n// calculate color difference according to the paper \"Measuring perceived color difference\n// using YIQ NTSC transmission color space in mobile applications\" by Y. Kotsarenko and F. Ramos\n\nfunction colorDelta(img1, img2, k, m, yOnly) {\n    let r1 = img1[k + 0];\n    let g1 = img1[k + 1];\n    let b1 = img1[k + 2];\n    let a1 = img1[k + 3];\n\n    let r2 = img2[m + 0];\n    let g2 = img2[m + 1];\n    let b2 = img2[m + 2];\n    let a2 = img2[m + 3];\n\n    if (a1 === a2 && r1 === r2 && g1 === g2 && b1 === b2) return 0;\n\n    if (a1 < 255) {\n        a1 /= 255;\n        r1 = blend(r1, a1);\n        g1 = blend(g1, a1);\n        b1 = blend(b1, a1);\n    }\n\n    if (a2 < 255) {\n        a2 /= 255;\n        r2 = blend(r2, a2);\n        g2 = blend(g2, a2);\n        b2 = blend(b2, a2);\n    }\n\n    const y1 = rgb2y(r1, g1, b1);\n    const y2 = rgb2y(r2, g2, b2);\n    const y = y1 - y2;\n\n    if (yOnly) return y; // brightness difference only\n\n    const i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2);\n    const q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);\n\n    const delta = 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;\n\n    // encode whether the pixel lightens or darkens in the sign\n    return y1 > y2 ? -delta : delta;\n}\n\nfunction rgb2y(r, g, b) { return r * 0.29889531 + g * 0.58662247 + b * 0.11448223; }\nfunction rgb2i(r, g, b) { return r * 0.59597799 - g * 0.27417610 - b * 0.32180189; }\nfunction rgb2q(r, g, b) { return r * 0.21147017 - g * 0.52261711 + b * 0.31114694; }\n\n// blend semi-transparent color with white\nfunction blend(c, a) {\n    return 255 + (c - 255) * a;\n}\n\nfunction drawPixel(output, pos, r, g, b) {\n    output[pos + 0] = r;\n    output[pos + 1] = g;\n    output[pos + 2] = b;\n    output[pos + 3] = 255;\n}\n\nfunction drawGrayPixel(img, i, alpha, output) {\n    const r = img[i + 0];\n    const g = img[i + 1];\n    const b = img[i + 2];\n    const val = blend(rgb2y(r, g, b), alpha * img[i + 3] / 255);\n    drawPixel(output, i, val, val, val);\n}\n","import {html} from 'lit-html';\r\n\r\nexport const template = (data) => html`\r\n  <div class=\"mdc-layout-grid\">\r\n    <div class=\"mdc-layout-grid__inner\">\r\n      <div class=\"mdc-layout-grid__cell--span-8\">\r\n        <canvas @click=\"${fullscreen}\" id=\"a\" width=\"1280\" height=\"720\"></canvas>\r\n        <div id=\"canvas-ctrl\">\r\n          <button @click=\"${data.play}\" class=\"mdc-icon-button material-icons\">${data.playing? html`stop`: html`play_arrow`}</button>\r\n          <input id=\"seek\" @input=\"${data.seek}\" .value=\"${data.position}\" max=\"${data.max}\" type=\"range\" style=\"${data.seekStyle}\">\r\n          <span id=\"time\">${data.time}</span>\r\n          <span id=\"total-time\">&nbsp;/ ${data.totalTime}</span>\r\n        </div>\r\n      </div>\r\n      <div class=\"mdc-layout-grid__cell--span-4\">\r\n        <div class=\"mdc-switch\">\r\n          <div class=\"mdc-switch__track\"></div>\r\n          <div class=\"mdc-switch__thumb-underlay\">\r\n            <div class=\"mdc-switch__thumb\">\r\n              <input @click=\"${data.showHeatmap}\" type=\"checkbox\" id=\"basic-switch\" class=\"mdc-switch__native-control\" role=\"switch\">\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <label for=\"basic-switch\">Show Heatmap</label>\r\n      </div>\r\n    </div>\r\n  </div>\r\n`;\r\n\r\nlet fullscreen = function() {\r\n  const context = document.getElementById('a').getContext('2d');\r\n  context.canvas.webkitRequestFullScreen()\r\n}\r\n","import {Storage} from '../storage.js';\r\nimport {Point, Points, Line, Circle, Rect, Heatmap} from '../geo.js';\r\nimport {REPLAY_FPS} from '../eye.js';\r\nimport {Fixation, GazePoint, GazeWindow} from '../eye.js';\r\nimport {FIXATION_COLOR, SACCADE_COLOR} from '../color.js';\r\n\r\nimport io from 'socket.io-client';\r\nimport {render as renderTmpl} from 'lit-html';\r\nimport {pixelmatch} from 'pixelmatch';\r\nimport {DateTime, Duration} from 'luxon';\r\n\r\nimport {template} from './template.js'\r\n\r\nexport function Replay(spec) {\r\n  let socket = undefined;\r\n\r\n  let lastFixatedEl = undefined;\r\n  let lastImg = undefined;\r\n  let gazeHistory = [];\r\n  let dataPoints = [];\r\n  let fixationCount = 0;\r\n  let prevFixation = undefined;\r\n  let storage = Storage({});\r\n  let surface = Rect({x: 0, y: 0, width: 1280, height: 720});\r\n  let tiles = surface.tiles().map(t => Rect(t));\r\n  let heatmap = Heatmap({tiles: tiles});\r\n  let context = context;\r\n  let frames = [];\r\n\r\n  let heatmapVisible = false;\r\n\r\n  let showHeatmap = function() {\r\n    heatmapVisible = !heatmapVisible;\r\n  }\r\n\r\n  let firstTimestamp = undefined;\r\n  let requestId = undefined;\r\n\r\n  let fps = REPLAY_FPS;\r\n  let now = undefined;\r\n  let then = Date.now();\r\n  let interval = 1000/fps;\r\n  let delta = undefined;\r\n\r\n  let play = function() {\r\n    console.log(\"playing\", spec.playing);\r\n    if (spec.playing) {\r\n      cancelAnimationFrame(requestId);\r\n    } else {\r\n      requestId = requestAnimationFrame(replay);\r\n    }\r\n    spec.playing = !spec.playing;\r\n    render(spec);\r\n  }\r\n\r\n  let seekStyle = function() {\r\n    return \"background-image:-webkit-linear-gradient(left, #b91f1f \" + spec.position/spec.max*100 + \"%, #a5a5a5 \" + spec.position/spec.max*100 + \"%, #a5a5a5 \" + (frames.length+spec.position)/spec.max*100 + \"%, #757575 \" + (frames.length+spec.position)/spec.max*100 + \"%)\";\r\n  }\r\n\r\n  let seek = function() {\r\n    let prevPosition = spec.position;\r\n    spec.position = +document.getElementById(\"seek\").value;\r\n    console.log(prevPosition, spec.position);\r\n    heatmap.reset();\r\n    if (spec.position < prevPosition) {\r\n      frames = [];\r\n      load(spec.position);\r\n    } else if (spec.position > prevPosition){\r\n      let diff = spec.position - prevPosition;\r\n      Array(diff).fill().forEach(function() { frames.shift(); });\r\n    }\r\n    render(spec);\r\n  }\r\n\r\n  let render = data => {\r\n    renderTmpl(template({...data, seekStyle: seekStyle()}), document.getElementById('view'));\r\n  }\r\n\r\n  let init = () => {\r\n    Object.assign(spec, {\r\n      playing: false,\r\n      position: 0,\r\n      time: '00:00:00',\r\n      totalTime: '--:--:--',\r\n      max: 1000,\r\n      play,\r\n      seek,\r\n      seekStyle: seekStyle(),\r\n      showHeatmap\r\n    });\r\n    render(spec);\r\n  }\r\n\r\n  init();\r\n\r\n  let replay = function() {\r\n    if (spec.position === spec.max) {\r\n      console.log(\"no frame\");\r\n      spec.playing = !spec.playing;\r\n      spec.position = 0;\r\n      load(spec.position);\r\n      spec.time = Duration.fromMillis(0).toFormat(\"hh:mm:ss\");\r\n      render(spec);\r\n      return;\r\n    }\r\n\r\n    now = Date.now();\r\n    delta = now - then;\r\n    if (delta > interval) {\r\n      then = now - (delta % interval);\r\n      let context = document.getElementById('a').getContext('2d');\r\n\r\n      let frame = frames.shift();\r\n\r\n      if (frame) {\r\n        let fixation = Fixation({x: frame.x, y: frame.y});\r\n\r\n        let count = heatmap.getCountArr();\r\n        let gaze_buffer = new ArrayBuffer(2*4);\r\n        let gaze = new Float32Array(gaze_buffer);\r\n        gaze[0] = fixation.getX();\r\n        gaze[1] = fixation.getY();\r\n\r\n        if (heatmap.getCountArr().buffer.length !== 0) {\r\n          worker.postMessage({count: count, gaze: gaze_buffer}, [count.buffer, gaze_buffer]);\r\n        }\r\n        //console.log(\"value\", frame);\r\n        let img = new Image();\r\n        img.onload = function() {\r\n          context.drawImage(img,0,0,1280,720);\r\n\r\n          Circle({x: fixation.getX(), y: fixation.getY(), r: 20}).render(context, FIXATION_COLOR);\r\n\r\n          if (prevFixation) {\r\n            Line({x1: prevFixation.getX(), y1: prevFixation.getY(), x2: fixation.getX(), y2: fixation.getY()}).render(context, SACCADE_COLOR);\r\n          }\r\n          prevFixation = fixation;\r\n\r\n          if (heatmapVisible) { heatmap.render(context); }\r\n          spec.time = Duration.fromMillis((frame.timestamp - firstTimestamp)).toFormat(\"hh:mm:ss\");\r\n          spec.position++;\r\n        }\r\n        img.src = frame.img;\r\n      }\r\n      render(spec);\r\n    }\r\n    requestId = requestAnimationFrame(replay);\r\n  }\r\n\r\n  let load = function(start) {\r\n    for (let frame=start; frame <= spec.max; frame++) {\r\n      storage.get(frame, (v) => {\r\n        if (v) {\r\n          frames.push(v);\r\n          //console.log(frames.length);\r\n          if (frames.length === spec.max) {\r\n            spec.totalTime = Duration.fromMillis((frames[spec.max-1].timestamp - frames[0].timestamp)).toFormat(\"hh:mm:ss\");\r\n            firstTimestamp = frames[0].timestamp;\r\n          }\r\n          render(spec);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  let worker = undefined;\r\n\r\n  let connect = function(context) {\r\n    context = context;\r\n    Rect({x: 0, y: 0, width: context.canvas.width, height: context.canvas.height}).clear(context);\r\n\r\n    worker = new Worker(\"/heatmap.js\");\r\n    worker.onmessage = function(e) {\r\n      //console.log(\"onmessage\", e.data);\r\n      heatmap.setCountArr(e.data);\r\n    }\r\n    worker.onerror = function(e) { console.log(\"onerror\", e); }\r\n\r\n    storage.getKeys(\"gaze\", (keys) => {\r\n      spec.max = keys.length;\r\n      console.log(\"max\", spec.max);\r\n      load(0);\r\n    });\r\n\r\n    //for (let i=0; i < 200; i++) {\r\n      //Rect({x: 0, y: 0, width: context.canvas.width, height: context.canvas.height}).clear(context);\r\n      //let p = Point({x: value.x, y: value.y});\r\n      //p.render(context, 'rgba(200,0,0,0.85)');\r\n\r\n      //if (gazeHistory.length === 30) { gazeHistory.shift(); }\r\n      //gazeHistory.push(p);\r\n\r\n      //Rect({x: 0, y: 0, width: context.canvas.width, height: context.canvas.height}).clear(context);\r\n      //fixationCount = 0;\r\n      //fixation = fixation.getFixation();\r\n      //Circle({x: fixation.x, y: fixation.y, r: 20}).render(context, 'rgba(255,255,255,0.85)');\r\n\r\n      //if (prevFixation) {\r\n      //  Line({x1: prevFixation.x, y1: prevFixation.y, x2: fixation.x, y2: fixation.y}).render(context, 'rgba(255,255,255,0.85)');\r\n      //}\r\n      //prevFixation = fixation;\r\n\r\n      //for (let i = 0; i < tiles.length; i++) {\r\n      //  if (tiles[i].containsPoint(fixation.x, fixation.y)) {\r\n      //    heatmap.setCount(i, heatmap.getCount(i)+1);\r\n      //  }\r\n      //}\r\n\r\n      //heatmap.render(context);\r\n\r\n      //Points({points: gazeHistory}).render(context, 'rgba(200,0,0,0.85)');\r\n      //tiles.forEach(t => t.render(context, 'rgba(255,255,255,0.85)'));\r\n\r\n      //const canvas2 = document.createElement('canvas');\r\n      //canvas2.width = 100;\r\n      //canvas2.height = 100;\r\n      //const context2 = canvas2.getContext('2d');\r\n\r\n      //context2.drawImage(document.getElementById('player'), 0, 0, canvas2.width, canvas2.height);\r\n      //let img2 = undefined;\r\n      //if (lastImg) {\r\n      //  img2 = context2.getImageData(0, 0, canvas2.width, canvas2.height);\r\n        //pixelmatch(lastImg.data, img2.data, null, canvas2.width, canvas2.height, {threshold: 0.1});\r\n      //}\r\n      //lastImg = context2.getImageData(0, 0, canvas2.width, canvas2.height);\r\n    //}\r\n  }\r\n\r\n  let disconnect = function() {\r\n    //socket.disconnect();\r\n    console.log(\"disconnect from replay\");\r\n  }\r\n\r\n  return Object.freeze({\r\n    connect,\r\n    disconnect\r\n  });\r\n}\r\n","import {Algorithm} from './algorithm.js'\r\n\r\nexport const RAW_DATA_COLOR = 'rgba(200,0,0,0.85)';\r\nexport const FIXATION_COLOR = 'rgba(255,255,255,0.85)';\r\nexport const SACCADE_COLOR = 'rgba(255,255,255,0.85)';\r\nexport const CLEAR_COLOR = 'rgb(0,0,0)';\r\n\r\nexport const DIFFERENT_COLORS = [];\r\nexport const HEATMAP_COLORS = [];\r\n\r\nfunction hsv2hsl(hue,sat,val) {\r\n  return [\r\n    hue,\r\n    sat*val/((hue=(2-sat)*val)<1?hue:2-hue),\r\n    hue/2\r\n  ]\r\n}\r\n\r\nfor (var i = 0; i < 10; i++) {\r\n  var h = (i * 0.618033988749895) % 1.0;\r\n  var s = 0.5;\r\n  var v = Math.sqrt(1.0 - ((i * 0.618033988749895) % 0.5));\r\n  var a = 0.5;\r\n\r\n  var hsl = hsv2hsl(h,s,v);\r\n\r\n  DIFFERENT_COLORS.push('hsla(' + Math.round(hsl[0]*255) + ',' + Math.round(hsl[1]*100) + '%,' + Math.round(hsl[2]*100) + '%,' + a + ')');\r\n}\r\n\r\nfor (let h = 0; h < 210; h++) {\r\n  HEATMAP_COLORS.push('hsla(' + (209 - h) + ', 50%, 50%,'+ 0.5 +')');\r\n}\r\n\r\nexport function Color(spec = {}) {\r\n  let algorithm = Algorithm({});\r\n\r\n  let heat = function(rel) {\r\n    let d = algorithm.limit(0, rel, 1)\r\n    if (rel === 0) return 'rgba(0,0,0,0)';\r\n    return HEATMAP_COLORS[Math.round((d * (HEATMAP_COLORS.length - 1)))];\r\n  }\r\n\r\n  return Object.freeze({\r\n    heat\r\n  });\r\n}\r\n","import {CLEAR_COLOR} from './color.js';\r\nimport {Color} from './color.js';\r\nimport {Algorithm} from './algorithm.js';\r\n\r\nexport const DEVICE_WIDTH = window.screen.width * window.devicePixelRatio;\r\nexport const DEVICE_HEIGHT = window.screen.height * window.devicePixelRatio;\r\n\r\nlet color = Color({});\r\nlet algorithm = Algorithm({});\r\n\r\nexport function Point(spec = {x: 0, y: 0}) {\r\n  let {x, y} = spec;\r\n\r\n  let getX = function() { return x; }\r\n  let getY = function() { return y; }\r\n\r\n  let render = function(context, fillStyle) {\r\n    context.fillStyle = fillStyle;\r\n    context.fillRect(x*context.canvas.width, y*context.canvas.height, 0.005*context.canvas.width, 0.005*context.canvas.width);\r\n  }\r\n\r\n  return Object.freeze({\r\n    getX,\r\n    getY,\r\n    render\r\n  });\r\n}\r\n\r\nexport function Points(spec = {points: []}) {\r\n  let {points} = spec;\r\n\r\n  let render = function(context, fillStyle) {\r\n    context.fillStyle = fillStyle;\r\n    points.forEach(function(p) {\r\n      p.render(context, fillStyle);\r\n    })\r\n  }\r\n\r\n  let renderTimeline = function(context, axis, fillStyle) {\r\n    context.fillStyle = fillStyle;\r\n    points.forEach(function(p, i) {\r\n      let dim = axis === 0? p.getX() : p.getY();\r\n      context.fillRect((i/30)*context.canvas.width, (1-dim)*context.canvas.height, context.canvas.width/30, 1);\r\n    })\r\n  }\r\n\r\n  return Object.freeze({\r\n    render,\r\n    renderTimeline\r\n  });\r\n}\r\n\r\nexport function Line(spec = {x1: 0, y1: 0, x2: 0, y2: 0}) {\r\n  let {x1, y1, x2, y2} = spec;\r\n\r\n  let render = function(context, strokeStyle) {\r\n    context.strokeStyle = strokeStyle\r\n    context.beginPath();\r\n    context.moveTo(x1*context.canvas.width, y1*context.canvas.height);\r\n    context.lineTo(x2*context.canvas.width, y2*context.canvas.height);\r\n    context.stroke();\r\n  }\r\n\r\n  return Object.freeze({\r\n    render\r\n  });\r\n}\r\n\r\nexport function Circle(spec = {x: 0, y: 0, r: 0}) {\r\n  let {x, y, r} = spec;\r\n\r\n  let getX = function() { return x; }\r\n  let getY = function() { return y; }\r\n  let getR = function() { return r; }\r\n\r\n  let render = function(context, strokeStyle, fillStyle) {\r\n    context.beginPath();\r\n    context.arc(x*context.canvas.width, y*context.canvas.height, r, 0, 2 * Math.PI);\r\n    if (fillStyle) {\r\n      context.fillStyle = fillStyle;\r\n      context.fill();\r\n    }\r\n    if (strokeStyle) {\r\n      context.strokeStyle = strokeStyle;\r\n      context.stroke();\r\n    }\r\n  }\r\n\r\n  return Object.freeze({\r\n    getX,\r\n    getY,\r\n    getR,\r\n    render\r\n  });\r\n}\r\n\r\nconst GT_BASE = [30, 15]\r\nconst GT_CONSIDER = [20, 20]\r\n\r\nexport function Rect(spec = {x: 0, y: 0, width: 0, height: 0}) {\r\n  let {x, y, width, height} = spec;\r\n\r\n  let getX = function() { return x; }\r\n  let getY = function() { return y; }\r\n  let getWidth = function() { return width; }\r\n  let getHeight = function() { return height; }\r\n\r\n  let clear = function(context, fillStyle) {\r\n    if (fillStyle) context.fillStyle = fillStyle;\r\n    else context.fillStyle = CLEAR_COLOR;\r\n    context.fillRect(0, 0, width, height);\r\n  }\r\n\r\n  let containsPoint = function(px, py) {\r\n    let w = width;\r\n    let h = height;\r\n\r\n    // At least one of the dimensions is negative\r\n    if ((w | h) < 0) { return false; }\r\n\r\n    // Note: if either dimension is zero, tests below must return false\r\n    if (px < x || py < y) { return false; }\r\n    w += x;\r\n    h += y;\r\n    // overflow || intersect\r\n    return ((w < x || w > px) && (h < y || h > py));\r\n  }\r\n\r\n  let tiles = function(tileSize = GT_BASE) {\r\n    let tiles = [];\r\n    let start = {x: x, y: y};\r\n    let shift = false;\r\n\r\n    while (start.y < y + height) {\r\n      let rectangle = {x: start.x, y: start.y, width: tileSize[0], height: tileSize[1]};\r\n      tiles.push(rectangle);\r\n\r\n      start.x = rectangle.x + rectangle.width;\r\n\r\n      if(start.x >= x + width) {\r\n        shift = !shift;\r\n        start.y += tileSize[1];\r\n        start.x = shift ? x - (tileSize[0] / 2) : 0;\r\n      }\r\n    }\r\n\r\n    return tiles;\r\n  }\r\n\r\n  let render = function(context, strokeStyle, fillStyle) {\r\n    if (strokeStyle) {\r\n      context.strokeStyle = strokeStyle;\r\n      context.strokeRect(x, y, width, height);\r\n    }\r\n    if (fillStyle) {\r\n      context.fillStyle = fillStyle;\r\n      context.fillRect(x, y, width, height);\r\n    }\r\n  }\r\n\r\n  return Object.freeze({\r\n    getX,\r\n    getY,\r\n    getWidth,\r\n    getHeight,\r\n    clear,\r\n    tiles,\r\n    containsPoint,\r\n    render\r\n  });\r\n}\r\n\r\nexport function Heatmap(spec = {tiles: []}) {\r\n  let {tiles} = spec;\r\n  let count = new Uint16Array(new ArrayBuffer(tiles.length*2));\r\n  let countClone = new Uint16Array(new ArrayBuffer(tiles.length*2));\r\n\r\n  let getCount = function(i) { return count[i]; }\r\n  let setCount = function(i, c) { count[i] = c; }\r\n  let getCountArr = function() { return count; }\r\n  let setCountArr = function(c) { count = c; }\r\n\r\n  let reset = function() {\r\n    count = new Uint16Array(new ArrayBuffer(tiles.length*2));\r\n    countClone = new Uint16Array(new ArrayBuffer(tiles.length*2));\r\n  }\r\n\r\n  let render = function(context) {\r\n    let count2 = count.buffer.byteLength !== 0? count : countClone;\r\n    let global_max = Math.max(...count2);\r\n\r\n    if (global_max !== 0) {\r\n      tiles.forEach(function(tile, i) {\r\n        if (count2[i]) {\r\n          let h = color.heat(algorithm.relative(0,count2[i],global_max));\r\n          tile.render(context, undefined, h);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (count.buffer.byteLength !== 0) {\r\n      countClone = count.slice(0);\r\n    };\r\n  }\r\n\r\n  return Object.freeze({\r\n    getCount,\r\n    setCount,\r\n    getCountArr,\r\n    setCountArr,\r\n    reset,\r\n    render\r\n  });\r\n}\r\n\r\n/* ANIMATION */\r\nexport function Ease(spec = {}) {\r\n  let linear = function(t,b,e,d) {\r\n    return (e-b)*t/d + b;\r\n  }\r\n\r\n  return Object.freeze({\r\n    linear\r\n  });\r\n}\r\n"],"sourceRoot":""}